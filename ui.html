<!DOCTYPE html>
<html>

<head>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --primary: #6366f1;
      --primary-soft: #eef2ff;
      --primary-hover: #4f46e5;
      --bg: #ffffff;
      --fg: #0f172a;
      --border: #f1f5f9;
      --muted: #64748b;
      --surface: #ffffff;
      --surface-alt: #f8fafc;
      --radius: 14px;
      --shadow-sm: 0 2px 4px 0 rgb(0 0 0 / 0.05);
      --shadow-md: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05);
      --shadow-lg: 0 20px 25px -5px rgb(0 0 0 / 0.05), 0 8px 10px -6px rgb(0 0 0 / 0.05);
    }

    [data-theme='dark'] {
      --bg: #0f172a;
      --fg: #f8fafc;
      --border: #1e293b;
      --muted: #94a3b8;
      --surface: #1e293b;
      --surface-alt: #0f172a;
      --primary-soft: #1e1b4b;
    }

    * {
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
    }

    body {
      font-family: 'Plus Jakarta Sans', sans-serif;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 20px;
      border-bottom: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(12px);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    h2 {
      margin: 0;
      font-size: 14px;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: var(--fg);
      text-transform: uppercase;
      background: linear-gradient(135deg, var(--fg) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    #status {
      font-size: 11px;
      font-weight: 500;
      color: var(--muted);
      background: var(--surface-alt);
      padding: 4px 10px;
      border-radius: 20px;
      border: 1px solid var(--border);
    }

    /* Tabs */
    .tabs-container {
      padding: 12px 20px;
      background: var(--surface);
    }

    .tabs {
      display: flex;
      background: var(--surface-alt);
      padding: 4px;
      border-radius: var(--radius);
      gap: 4px;
    }

    .tab {
      flex: 1;
      padding: 8px;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      border-radius: calc(var(--radius) - 2px);
      color: var(--muted);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .tab.active {
      background: var(--surface);
      color: var(--primary);
      box-shadow: var(--shadow-sm);
    }

    .tab-content {
      flex: 1;
      display: none;
      flex-direction: column;
      padding: 0 20px 20px 20px;
      overflow-y: auto;
    }

    .tab-content.active {
      display: flex;
    }

    /* Node List */
    .node-list {
      flex: 1;
      min-height: 200px;
      overflow-y: auto;
      background: transparent;
      padding: 4px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .node-item {
      padding: 16px;
      border-radius: var(--radius);
      background: var(--surface);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .node-item:hover {
      border-color: var(--primary-soft);
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    .node-key {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 10px;
      color: var(--primary);
      margin-bottom: 4px;
      opacity: 0.8;
      font-weight: 500;
    }

    .node-text {
      font-size: 12px;
      line-height: 1.5;
      font-weight: 500;
      padding: 2px 4px;
      margin: -2px -4px;
      border-radius: 4px;
      outline: none;
      transition: background 0.2s;
    }

    .node-text:hover {
      background: var(--primary-soft);
    }

    .node-text:focus {
      background: var(--bg);
      box-shadow: 0 0 0 2px var(--primary-soft);
    }

    .manual-badge {
      display: inline-flex;
      align-items: center;
      font-size: 9px;
      font-weight: 700;
      color: var(--primary);
      background: var(--primary-soft);
      padding: 1px 5px;
      border-radius: 4px;
      margin-left: 6px;
      text-transform: uppercase;
    }

    /* Preview Bar */
    .preview-bar {
      display: flex;
      gap: 8px;
      padding: 16px 0;
      overflow-x: auto;
      scrollbar-width: none;
    }

    .preview-bar::-webkit-scrollbar {
      display: none;
    }

    .lang-chip {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 30px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      background: var(--bg);
      color: var(--muted);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .lang-chip:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: var(--primary-soft);
    }

    .lang-chip.active {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.3);
      transform: translateY(-1px) scale(1.02);
    }

    /* Buttons & Inputs */
    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }

    button {
      padding: 12px 16px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: var(--radius);
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 6px -1px rgba(99, 102, 241, 0.1), 0 2px 4px -1px rgba(99, 102, 241, 0.06);
    }

    button:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.2), 0 4px 6px -2px rgba(99, 102, 241, 0.1);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--fg);
      box-shadow: var(--shadow-sm);
    }

    button.secondary:hover {
      background: var(--surface-alt);
      border-color: var(--primary-soft);
      box-shadow: var(--shadow-md);
    }

    button.tertiary {
      background: transparent;
      color: var(--muted);
      font-size: 10px;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 6px;
      border: none;
      box-shadow: none;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      transition: all 0.2s;
    }

    button.tertiary:hover {
      background: var(--primary-soft);
      color: var(--primary);
      transform: none;
      box-shadow: none;
    }

    .input-group {
      margin-bottom: 20px;
    }

    label.field-label {
      display: block;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    input {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border);
      background: var(--surface-alt);
      color: var(--fg);
      border-radius: var(--radius);
      font-size: 13px;
      outline: none;
      transition: all 0.2s;
    }

    input:focus {
      border-color: var(--primary);
      background: var(--surface);
      box-shadow: 0 0 0 3px var(--primary-soft);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.4);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 24px;
      animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal-container {
      background: var(--surface);
      border-radius: 20px;
      width: 100%;
      max-width: 320px;
      padding: 24px;
      box-shadow: var(--shadow-lg);
      border: 1px solid var(--border);
      transform: scale(1);
      animation: scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes scaleIn {
      from {
        transform: scale(0.9);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .lang-grid {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin: 16px 0 24px 0;
    }

    .lang-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .lang-option:hover:not([style*="not-allowed"]) {
      background: var(--surface-alt);
    }

    .lang-option input[type="radio"] {
      width: 18px;
      height: 18px;
      margin: 0;
      accent-color: var(--primary);
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--muted);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .hidden {
      display: none;
    }

    /* Toggle Switch */
    .toggle-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 4px;
      margin-bottom: 8px;
    }

    .toggle-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .switch {
      position: relative;
      display: inline-block;
      width: 32px;
      height: 18px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background-color: var(--border);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 50%;
      box-shadow: var(--shadow-sm);
    }

    input:checked+.slider {
      background-color: var(--primary);
    }

    input:checked+.slider:before {
      transform: translateX(14px);
    }
  </style>
</head>

<body>
  <div class="header">
    <h2>Polyglot UI</h2>
    <div style="display: flex; gap: 8px; align-items: center;">
      <button id="clearSessionBtn" class="tertiary">Clear</button>
      <div id="status">Ready</div>
    </div>
  </div>

  <div class="tabs-container">
    <div class="tabs">
      <div class="tab active" data-tab="locale">Localize</div>
      <div class="tab" data-tab="settings">Settings</div>
    </div>
  </div>

  <!-- Locale Tab -->
  <div id="locale" class="tab-content active">
    <div class="node-list" id="nodeList">
      <div style="padding: 60px 20px; text-align: center; color: var(--muted); font-size: 13px; font-weight: 500;">
        Select an element and click Refresh to begin.
      </div>
    </div>

    <div class="toggle-container">
      <span class="toggle-label">Live Canvas Preview</span>
      <label class="switch">
        <input type="checkbox" id="livePreviewToggle">
        <span class="slider"></span>
      </label>
    </div>

    <div class="preview-bar" id="previewBar">
      <div class="lang-chip active" data-lang="en">English</div>
      <div class="lang-chip" data-lang="pseudo"
        style="background: var(--surface); border: 1px dashed var(--primary); color: var(--primary);">Stress Test</div>
      <div class="lang-chip" data-lang="fr">French</div>
      <div class="lang-chip" data-lang="de">German</div>
      <div class="lang-chip" data-lang="hi">Hindi</div>
      <div class="lang-chip" data-lang="es">Spanish</div>
    </div>

    <div class="actions">
      <button id="translateBtn">
        <span class="spinner hidden" id="translateSpinner"></span>
        Translate
      </button>
      <button class="secondary" id="scanBtn">Refresh List</button>
    </div>
    <div class="actions">
      <button class="secondary" id="applyToDesignBtn" style="width: 100%;">Generate Copy</button>
      <button class="secondary" id="exportBtn" style="width: 100%;">Export JSON</button>
    </div>
    <button class="secondary hidden" id="revertBtn" style="width: 100%; margin-top: 2px;">Revert Design</button>
  </div>

  <!-- Settings Tab -->
  <div id="settings" class="tab-content">
    <div style="padding-top: 10px;">
      <div class="input-group">
        <label class="field-label">Lingo.dev API Key</label>
        <input type="password" id="apiKey" placeholder="Paste your key here...">
        <div style="font-size: 11px; color: var(--muted); margin-top: 8px; line-height: 1.4;">
          Needed for high-quality AI translations.
        </div>
      </div>

      <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border);">
        <button class="secondary" id="clearBtn"
          style="width: 100%; color: #ef4444; border-color: rgba(239, 68, 68, 0.2);">
          Clear All Data
        </button>
      </div>
    </div>
  </div>

  <!-- Export Modal -->
  <div class="modal-overlay" id="exportModal">
    <div class="modal-container">
      <div class="modal-header">
        <h3 class="modal-title">Export Language</h3>
        <div class="hint">Select the language to export.</div>
      </div>
      <div class="lang-grid">
        <!-- Radio buttons will be injected here -->
      </div>
      <div class="modal-actions">
        <button class="secondary" id="cancelExport">Cancel</button>
        <button id="confirmExport">Download</button>
      </div>
    </div>
  </div>

  <script>
    // Tab switching logic
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

        tab.classList.add('active');
        document.getElementById(tab.dataset.tab).classList.add('active');
        setStatus(`Switched to ${tab.dataset.tab}`);
      });
    });

    const statusEl = document.getElementById('status');
    function setStatus(text, isError = false) {
      statusEl.textContent = text;
      statusEl.style.color = isError ? '#ef4444' : 'var(--muted)';
      console.log(`[Plugin UI] ${text}`);
    }

    let extractedNodes = [];
    let translations = { en: {}, fr: {}, de: {}, hi: {}, es: {} };

    const apiKeyInput = document.getElementById('apiKey');
    const scanBtn = document.getElementById('scanBtn');
    const translateBtn = document.getElementById('translateBtn');
    const exportBtn = document.getElementById('exportBtn');
    const applyToDesignBtn = document.getElementById('applyToDesignBtn');
    const revertBtn = document.getElementById('revertBtn');
    const livePreviewToggle = document.getElementById('livePreviewToggle');
    const nodeList = document.getElementById('nodeList');
    const previewBar = document.getElementById('previewBar');
    const translateSpinner = document.getElementById('translateSpinner');
    const clearSessionBtn = document.getElementById('clearSessionBtn');

    // Load Settings
    try {
      apiKeyInput.value = localStorage.getItem('lingo_api_key') || '';
    } catch (e) { }

    apiKeyInput.addEventListener('change', (e) => localStorage.setItem('lingo_api_key', e.target.value));

    clearSessionBtn.addEventListener('click', () => {
      extractedNodes = [];
      translations = { en: {}, fr: {}, de: {}, hi: {}, es: {} };
      renderNodes('en');
      parent.postMessage({ pluginMessage: { type: 'revert-preview' } }, '*');
      revertBtn.classList.add('hidden');
      setStatus('Session cleared');
    });

    document.getElementById('clearBtn').onclick = () => {
      localStorage.clear();
      apiKeyInput.value = '';

      // Reset local state
      extractedNodes = [];
      translations = { en: {}, fr: {}, de: {}, hi: {}, es: {} };

      // Clear UI
      renderNodes('en');

      // Clear Figma Storage
      parent.postMessage({ pluginMessage: { type: 'clear-storage' } }, '*');

      setStatus('All data cleared');
      alert('Local storage and design metadata cleared.');
    };

    scanBtn.addEventListener('click', () => {
      setStatus('Scanning...');
      parent.postMessage({ pluginMessage: { type: 'scan' } }, '*');
    });

    translateBtn.addEventListener('click', async () => {
      const apiKey = apiKeyInput.value;
      if (!apiKey) { alert('Go to Settings to enter Lingo.dev API Key'); return; }
      if (extractedNodes.length === 0) { alert('Scan design for text first'); return; }

      setStatus('Translating (via Background)...');
      translateSpinner.classList.remove('hidden');
      translateBtn.disabled = true;

      const workflowId = 'figma_' + Math.random().toString(36).substring(2, 11);
      const sourceData = {};
      extractedNodes.forEach(node => {
        // Skip nodes with manual overrides for this specific session? 
        // Or send them anyway but prioritize manual? 
        // Better: Skip sending to AI if already manually tweaked to save tokens and prevent overwrite.
        const currentLang = previewBar.querySelector('.lang-chip.active').dataset.lang; // Wait, translate handles multiple langs
        // For simplicity: Send all but filter results later.
        sourceData[node.id] = node.text;
      });

      try {
        const targetLangs = ['fr', 'de', 'hi', 'es'];
        setStatus(`Translating (${targetLangs.length} languages)...`);

        const fetchWithTimeout = async (lang) => {
          const targetUrl = 'https://engine.lingo.dev/i18n';
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

          try {
            const response = await fetch(proxyUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json; charset=utf-8',
                'Authorization': `Bearer ${apiKey}`
              },
              signal: controller.signal,
              body: JSON.stringify({
                params: { workflowId, fast: false },
                locale: { source: 'en', target: lang },
                data: sourceData
              })
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`API Error ${response.status} (${lang}): ${errorText}`);
            }

            const json = await response.json();
            return { lang, data: json.data };
          } catch (e) {
            clearTimeout(timeoutId);
            throw e;
          }
        };

        const fetchResults = await Promise.all(targetLangs.map(fetchWithTimeout));
        const results = {};
        fetchResults.forEach(res => { results[res.lang] = res.data; });

        // Process results locally
        Object.keys(results).forEach(lang => {
          extractedNodes.forEach(node => {
            // ONLY apply AI results if not manually overridden
            if (!node.manualFlags || !node.manualFlags[lang]) {
              translations[lang][node.id] = results[lang][node.id];
            }
          });
        });

        // Sync with Figma for persistence
        parent.postMessage({ pluginMessage: { type: 'store-translations', data: results } }, '*');

        setStatus('Ready');
        translateSpinner.classList.add('hidden');
        translateBtn.disabled = false;

        const activeChip = previewBar.querySelector('.lang-chip.active');
        const lang = activeChip ? activeChip.dataset.lang : 'en';
        renderNodes(lang);

        alert('Translation complete!');
      } catch (err) {
        console.error('[UI] Translation Error:', err);
        setStatus('Translation failed', true);
        translateSpinner.classList.add('hidden');
        translateBtn.disabled = false;
        alert(`Translation failed: ${err.message}`);
      }
    });

    function pseudoLocalize(text) {
      const charMap = {
        'a': 'à', 'e': 'é', 'i': 'î', 'o': 'ô', 'u': 'û',
        'A': 'À', 'E': 'É', 'I': 'Î', 'O': 'Ô', 'U': 'Û',
        'c': 'ç', 'C': 'Ç', 'n': 'ñ', 'N': 'Ñ'
      };

      let result = text.split('').map(char => charMap[char] || char).join('');
      // Expansion logic: Duplicate vowels to simulate longer languages like German/French
      result = result.replace(/[àéîôû]/g, match => match + match);
      return `[!!! ${result} !!!]`;
    }

    function renderNodes(lang = 'en') {
      if (extractedNodes.length === 0) {
        nodeList.innerHTML = '<div style="padding: 40px 20px; text-align: center; color: var(--muted); font-size: 11px;">No visible text nodes.</div>';
        return;
      }
      nodeList.innerHTML = extractedNodes.map(node => {
        let textToDisplay = (translations[lang] && translations[lang][node.id]) || node.text;
        if (lang === 'pseudo') {
          textToDisplay = pseudoLocalize(node.text);
        }

        const isManual = node.manualFlags && node.manualFlags[lang];

        return `
          <div class="node-item" data-id="${node.id}">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;">
              <div class="node-key">${node.key}</div>
              ${isManual ? '<span class="manual-badge">Custom</span>' : ''}
            </div>
            <div class="node-text" contenteditable="${lang !== 'en' && lang !== 'pseudo'}" data-id="${node.id}">${textToDisplay}</div>
          </div>
        `;
      }).join('');

      // Add listeners to editable fields
      document.querySelectorAll('.node-text[contenteditable="true"]').forEach(el => {
        el.addEventListener('blur', (e) => {
          const id = e.target.dataset.id;
          const newText = e.target.innerText;
          const activeChip = previewBar.querySelector('.lang-chip.active');
          const lang = activeChip ? activeChip.dataset.lang : 'en';

          if (translations[lang][id] !== newText) {
            translations[lang][id] = newText;

            // Mark as manual locally
            const node = extractedNodes.find(n => n.id === id);
            if (node) {
              if (!node.manualFlags) node.manualFlags = {};
              node.manualFlags[lang] = true;
              renderNodes(lang); // Re-render to show badge
            }

            parent.postMessage({
              pluginMessage: {
                type: 'update-manual-translation',
                id,
                lang,
                text: newText
              }
            }, '*');

            triggerPreview(lang);
          }
        });

        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            e.target.blur();
          }
        });
      });
    }

    function triggerPreview(lang) {
      if (lang === 'en' || !livePreviewToggle.checked) {
        if (lang === 'en') {
          parent.postMessage({ pluginMessage: { type: 'revert-preview' } }, '*');
          revertBtn.classList.add('hidden');
        }
        return;
      }

      const payload = extractedNodes.map(n => {
        let translatedText = (translations[lang] && translations[lang][n.id]) || n.text;
        if (lang === 'pseudo') translatedText = pseudoLocalize(n.text);
        return { id: n.id, translatedText };
      });

      const hasChanges = lang === 'pseudo' || payload.some(p => p.translatedText !== extractedNodes.find(en => en.id === p.id).text);

      if (hasChanges) {
        parent.postMessage({
          pluginMessage: {
            type: 'preview-translation',
            translations: payload,
            language: lang === 'pseudo' ? 'Stress' : lang
          }
        }, '*');
        revertBtn.classList.remove('hidden');
      } else {
        setStatus(`Translate to ${lang.toUpperCase()} first for live preview`);
      }
    }

    window.addEventListener('message', (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      if (msg.type === 'scan-results') {
        extractedNodes = msg.data || [];

        // Reset translations and manual flags
        translations = { en: {}, fr: {}, de: {}, hi: {}, es: {} };

        extractedNodes.forEach(node => {
          translations.en[node.id] = node.text;
          if (node.translations) {
            Object.keys(node.translations).forEach(lang => {
              translations[lang][node.id] = node.translations[lang];
            });
          }
        });

        // Ensure we render the active language immediately
        const activeChip = previewBar.querySelector('.lang-chip.active');
        const lang = activeChip ? activeChip.dataset.lang : 'en';

        renderNodes(lang);
        setStatus(`Found ${extractedNodes.length} nodes`);
      }

      if (msg.type === 'apply-complete') {
        setStatus('Ready');
      }

      if (msg.type === 'apply-error') {
        setStatus('Error', true);
      }
    });

    previewBar.addEventListener('click', (e) => {
      const chip = e.target.closest('.lang-chip');
      if (!chip) return;

      const lang = chip.dataset.lang;
      document.querySelectorAll('.lang-chip').forEach(c => c.classList.remove('active'));
      chip.classList.add('active');

      renderNodes(lang);
      triggerPreview(lang);
    });

    livePreviewToggle.addEventListener('change', () => {
      const activeChip = previewBar.querySelector('.lang-chip.active');
      const lang = activeChip ? activeChip.dataset.lang : 'en';

      if (!livePreviewToggle.checked) {
        parent.postMessage({ pluginMessage: { type: 'revert-preview' } }, '*');
        revertBtn.classList.add('hidden');
      } else {
        triggerPreview(lang);
      }
    });

    revertBtn.addEventListener('click', () => {
      parent.postMessage({ pluginMessage: { type: 'revert-preview' } }, '*');
      revertBtn.classList.add('hidden');
      document.querySelectorAll('.lang-chip').forEach(c => c.classList.remove('active'));
      const enChip = previewBar.querySelector('[data-lang="en"]');
      if (enChip) enChip.classList.add('active');
      renderNodes('en');
    });

    applyToDesignBtn.addEventListener('click', () => {
      const activeChip = previewBar.querySelector('.lang-chip.active');
      if (!activeChip) return;
      const lang = activeChip.dataset.lang;

      setStatus(`Generating ${lang.toUpperCase()} copy...`);
      parent.postMessage({
        pluginMessage: {
          type: 'apply-translation',
          translations: extractedNodes.map(n => ({
            id: n.id,
            translatedText: (lang === 'pseudo' ? pseudoLocalize(n.text) : (translations[lang] && translations[lang][n.id]) || n.text)
          })),
          language: lang
        }
      }, '*');
    });

    const exportModal = document.getElementById('exportModal');
    const cancelExport = document.getElementById('cancelExport');
    const confirmExport = document.getElementById('confirmExport');

    exportBtn.addEventListener('click', () => {
      if (extractedNodes.length === 0) {
        alert('Scan design for text first');
        return;
      }

      const langGrid = exportModal.querySelector('.lang-grid');
      langGrid.innerHTML = '';

      const langs = [
        { id: 'en', name: 'English' },
        { id: 'fr', name: 'French' },
        { id: 'de', name: 'German' },
        { id: 'hi', name: 'Hindi' },
        { id: 'es', name: 'Spanish' }
      ];

      langs.forEach(lang => {
        const hasData = lang.id === 'en' || (translations[lang.id] && Object.keys(translations[lang.id]).length > 0);
        const label = document.createElement('label');
        label.className = 'lang-option';
        if (!hasData) {
          label.style.opacity = '0.5';
          label.style.cursor = 'not-allowed';
        }
        label.innerHTML = `
          <input type="radio" name="exportLang" value="${lang.id}" ${!hasData ? 'disabled' : ''} ${lang.id === 'en' ? 'checked' : ''}>
          <span>${lang.name} ${!hasData ? '(No data)' : ''}</span>
        `;
        langGrid.appendChild(label);
      });

      exportModal.classList.add('active');
    });

    cancelExport.addEventListener('click', () => {
      exportModal.classList.remove('active');
    });

    confirmExport.addEventListener('click', async () => {
      const selectedLang = exportModal.querySelector('input[name="exportLang"]:checked');
      if (!selectedLang) return;

      const lang = selectedLang.value;
      const data = {};

      extractedNodes.forEach(node => {
        data[node.id] = (translations[lang] && translations[lang][node.id]) || node.text;
      });

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${lang}.json`;
      a.click();
      URL.revokeObjectURL(url);

      exportModal.classList.remove('active');
      setStatus(`Exported ${lang}.json`);
    });
  </script>
</body>

</html>